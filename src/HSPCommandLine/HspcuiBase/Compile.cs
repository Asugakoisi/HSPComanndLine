using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using HspcuiBase.Options;
using HspcuiBase.Utils;
using System.Reflection;

namespace HspcuiBase.Compile
{
    public partial class Compile
    {
#if !LINUX
#region hspcmp.dll
        [DllImport("hspcmp.dll", EntryPoint = "hsc_ini")]
        private static extern bool Hsc_ini(int bm, byte[] p1, int p2, int p3);
        [DllImport("hspcmp.dll", EntryPoint = "hsc_objname")]
        private static extern bool Hsc_objname(int bm, byte[] p1, int p2, int p3);
        [DllImport("hspcmp.dll", EntryPoint = "hsc_compath")]
        private static extern bool Hsc_compath(int bm, byte[] p1, int p2, int p3);
        [DllImport("hspcmp.dll", EntryPoint = "hsc_comp")]
        private static extern bool Hsc_comp(int p1, int p2, int p3, int p4);
        [DllImport("hspcmp.dll", EntryPoint = "hsc_getmes")]
        private static extern bool Hsc_getmes(byte[] p1, int p2, int p3, int p4);
        [DllImport("hspcmp.dll", EntryPoint = "hsc3_getruntime")]
        private static extern bool Hsc3_getruntime(byte[] p1, byte[] p2, int p3, int p4);
        [DllImport("hspcmp.dll", EntryPoint = "hsc3_make")]
        private static extern bool Hsc3_make(int bm, byte[] p2, int p3, int p4);
        [DllImport("hspcmp.dll", EntryPoint = "hsc_refname")]
        private static extern bool Hsc_refname(int bm, byte[] p2, int p3, int p4);
#endregion
        [DllImport("Kernel32.dll", CharSet = CharSet.Unicode)]
        static extern bool SetDllDirectory(string lpPathName);
#endif
        public List<string> CompileMessage { get; set; }
        public string SourceFilePath { get; }
        public string CommonDirectoryPath { get; }
        public string SystemDirectoryPath { get; }
        public string RuntimeDirectoryPath { get; }
        public bool CatchErrors { get; }

        public Compile(string sourceFilePath, string commonDirectoryPath = "common", string systemDirectoryPath = "", string runtimeDirectoryPath = "runtime", bool catchErrors = true)
        {
            if (sourceFilePath is null)
            {
                if(catchErrors) throw new ArgumentNullException(nameof(sourceFilePath));
            }
            SourceFilePath = sourceFilePath;
            CommonDirectoryPath = commonDirectoryPath;
            SystemDirectoryPath = systemDirectoryPath;
            RuntimeDirectoryPath = runtimeDirectoryPath;
            CatchErrors = catchErrors;
            CompileMessage = new List<string>();
            if (!SystemDirectoryPath.EndsWith(Path.DirectorySeparatorChar.ToString()))
                SystemDirectoryPath += Path.DirectorySeparatorChar;
            if (!CommonDirectoryPath.EndsWith(Path.DirectorySeparatorChar.ToString()))
                CommonDirectoryPath += Path.DirectorySeparatorChar;
            if (!RuntimeDirectoryPath.EndsWith(Path.DirectorySeparatorChar.ToString()))
                RuntimeDirectoryPath += Path.DirectorySeparatorChar;
#if !LINUX
            SetDllDirectory("");
            SetDllDirectory(SystemDirectoryPath);
#endif
        }

        public bool CreateAssemblyInfo(Platform platform = Platform.x86, ModeOptions mode = ModeOptions.None, PreprocessOptions ppout = PreprocessOptions.None,
            string name = "")
        {
            if (Path.GetExtension(SourceFilePath).Equals(".hsp"))
            {
                var outStream = new StreamWriter(Path.Combine(Path.GetDirectoryName(SourceFilePath), "AssemblyInfo.hsp"), false,
                    mode.HasFlag(ModeOptions.OutputUTF8) ? new UTF8Encoding(false) : Encoding.GetEncoding("Shift_JIS"));
                var stream = new FileStream(SourceFilePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
                var reader = new StreamReader(stream, ppout.HasFlag(PreprocessOptions.InputUTF8) ? new UTF8Encoding(false) : Encoding.GetEncoding("Shift_JIS"));
                try
                {
                    outStream.WriteLine($"; auto generated by hspcui v{Assembly.GetExecutingAssembly().GetName().Version}");
#if !LINUX
                    if (ppout.HasFlag(PreprocessOptions.InputUTF8))
                        outStream.WriteLine($"; use utf8{Environment.NewLine}#include \"hsp3utf.as\"");
                    if (platform.HasFlag(Platform.x64))
                        outStream.WriteLine($"; x64 platform{Environment.NewLine}#include \"hsp3_64.as\"");
                    if (!string.IsNullOrEmpty(name))
                        outStream.WriteLine($"; assembly name{Environment.NewLine}#packopt name \"{name}\"");
#endif
                    if (mode.HasFlag(ModeOptions.OnlyPreprocess))
                        outStream.WriteLine($"; output preprocessor file{Environment.NewLine}#cmpopt ppout 1");
                    outStream.Close();
                    // sourceFile に include を追加する。
                    outStream = new StreamWriter(stream, ppout.HasFlag(PreprocessOptions.InputUTF8) ? new UTF8Encoding(false) : Encoding.GetEncoding("Shift_JIS"));
                    var file = reader.ReadToEnd();
                    if (!Regex.IsMatch(file, @"#include(\s*)" + "\"AssemblyInfo.hsp\""))
                        file = "#include \"AssemblyInfo.hsp\"" + Environment.NewLine + file;
                    stream.Position = 0;
                    stream.SetLength(0);
                    outStream.Write(file);
                    outStream.Flush();
                    reader?.Close();
                    return true;
                }
                catch (Exception ex)
                {
                    if (CatchErrors)
                        throw;
                    else
                        CompileMessage = ex.Message.TrimEnd('\n').TrimEnd('\r').Replace("\r\n", "\n").Split('\n').ToList();
                    return false;
                }
                finally
                {
                    stream.Close();
                    reader?.Close();
                    if (outStream.BaseStream.CanWrite)
                        outStream?.Close();
                }
            }
            else
                CompileMessage = new List<string>() { Properties.Resources.NotGenerateAssemblyInfo };
            return false;
        }

#if !LINUX
        public bool CreateObj(ref string axName, string refName, ModeOptions mode = 0, PreprocessOptions ppout = 0, bool debug = false)
        {
            CompileMessage.Clear();
            string cmpMessage = "";
            Encoding sjisEnc = Encoding.GetEncoding("Shift_JIS");
            byte[] errbuf = new byte[32000];
            bool res;
            if (mode.HasFlag(ModeOptions.OutputStrmap) && !mode.HasFlag(ModeOptions.OnlyPreprocess))
            {
                string beforeAxName = axName;
                bool onDebugOption = false;
                if (mode.HasFlag(ModeOptions.Debug))
                    mode &= ~ModeOptions.Debug;
                Hsc_ini(0, sjisEnc.GetBytes(SourceFilePath), 0, 0);
                if (!string.IsNullOrEmpty(axName))
                    Hsc_objname(0, sjisEnc.GetBytes(Path.ChangeExtension(axName, "strmap")), 0, 0);
                else
                    axName = Path.ChangeExtension(SourceFilePath, "strmap");
                if (!string.IsNullOrEmpty(refName))
                    Hsc_refname(0, sjisEnc.GetBytes(refName), 0, 0);
                Hsc_compath(0, sjisEnc.GetBytes(CommonDirectoryPath), 0, 0);
                res = Hsc_comp((int)mode, (int)ppout, Convert.ToInt32(debug), 0);
                Hsc_getmes(errbuf, 0, 0, 0);   // 結果を取得
                cmpMessage += sjisEnc.GetString(errbuf).Replace("\0", "");
                if (onDebugOption) mode |= ModeOptions.Debug;
                if (res) return true;
                else
                {
#if net50
                    File.Move(Path.ChangeExtension(axName, "ax"), axName, true);
#else
                    if (File.Exists(Path.ChangeExtension(axName, "ax")))
                        File.Delete(Path.ChangeExtension(axName, "ax"));
                    File.Move(Path.ChangeExtension(axName, "ax"), axName);
#endif
                    if (!ppout.HasFlag(PreprocessOptions.MakePackfile) && !ppout.HasFlag(PreprocessOptions.Ver26) && !ppout.HasFlag(PreprocessOptions.MakeAHT) && !mode.HasFlag(ModeOptions.Debug)) return false;
                    cmpMessage += Environment.NewLine;
                    mode &= ~ModeOptions.OutputStrmap;
                    axName = beforeAxName;
                }
            }
            Hsc_ini(0, sjisEnc.GetBytes(SourceFilePath), 0, 0);
            if (!string.IsNullOrEmpty(axName))
            {
                axName = Path.ChangeExtension(axName, "ax");
                Hsc_objname(0, sjisEnc.GetBytes(axName), 0, 0);
            }
            else
                axName = Path.ChangeExtension(SourceFilePath, "ax");
            if (!string.IsNullOrEmpty(refName))
                Hsc_refname(0, sjisEnc.GetBytes(refName), 0, 0);
            Hsc_compath(0, sjisEnc.GetBytes(CommonDirectoryPath), 0, 0);
            res = Hsc_comp((int)mode, (int)ppout, Convert.ToInt32(debug), 0);
            errbuf = new byte[32000];
            Hsc_getmes(errbuf, 0, 0, 0);   // 結果を取得
            cmpMessage += sjisEnc.GetString(errbuf).Replace("\0", "");
            CompileMessage.AddRange(cmpMessage.TrimEnd('\n').TrimEnd('\r').Replace("\r\n", "\n").Split('\n'));
            return res;
        }

        public bool CreateObj(string axName, string refName, ModeOptions mode = 0, PreprocessOptions ppout = 0, bool debug = false)
        {
            return CreateObj(ref axName, refName, mode, ppout, debug);
        }

        public int ExcuteAx(string axname, string option = "")
        {
            CompileMessage.Clear();
            try
            {
                if (!File.Exists(axname)) throw new Exception(string.Format(Properties.Resources.NotFoundA, axname));

                var runtimeName = GetRuntime(axname);

                var startInfo = new ProcessStartInfo
                {
                    FileName = string.IsNullOrEmpty(runtimeName) ? "hsp3.exe" : runtimeName,
                    Arguments = $"{Path.GetFullPath(axname)} {option}",
                    UseShellExecute = false,
                    WorkingDirectory = Path.GetDirectoryName(axname)
                };
                if (!File.Exists(startInfo.FileName))
                {
                    if (!File.Exists(Path.Combine(SystemDirectoryPath, startInfo.FileName)))
                    {
                        Console.WriteLine(Properties.Resources.NotFoundA, Path.Combine(SystemDirectoryPath, startInfo.FileName));
                        if (!File.Exists(Path.Combine(RuntimeDirectoryPath, startInfo.FileName)))
                            throw new Exception(string.Format(Properties.Resources.NotFoundA, Path.Combine(RuntimeDirectoryPath, startInfo.FileName)));
                        else
                            startInfo.FileName = Path.Combine(RuntimeDirectoryPath, startInfo.FileName);
                    }
                    else
                        startInfo.FileName = Path.Combine(SystemDirectoryPath, startInfo.FileName);
                }
                using (var process = new Process
                {
                    StartInfo = startInfo
                })
                {
                    if (!process.Start())
                    {
                        throw new Exception(string.Format(Properties.Resources.CouldNotRunRuntime, process.StartInfo.FileName));
                    }
                    process.WaitForExit();
                    CompileMessage.Add($"ReturnCode[{axname}] " + process.ExitCode.ToString());
                    return process.ExitCode;
                }
            }
            catch (Exception ex)
            {
                if (CatchErrors) throw;
                else CompileMessage.AddRange(ex.Message.TrimEnd('\n').TrimEnd('\r').Replace("\r\n", "\n").Split('\n'));
                return -2;
            }
        }

        public int ExecuteExe(string exeName, string option = "")
        {
            CompileMessage.Clear();
            var process = new Process();
            int res = -100;
            string cmpMessage = "";
            try
            {
                process.StartInfo.FileName = exeName;
                process.StartInfo.Arguments = option;
                if (!string.IsNullOrEmpty(Path.GetDirectoryName(exeName)))
                    process.StartInfo.WorkingDirectory = Path.GetDirectoryName(exeName);
                if (!process.Start())
                {
                    throw new Exception(string.Format(Properties.Resources.CouldNotRun, process.StartInfo.FileName));
                }
                process.WaitForExit();
                cmpMessage += $"ReturnCode[{exeName}] " + process.ExitCode.ToString();
                res = process.ExitCode;
            }
            catch(Exception ex)
            {
                if (CatchErrors) throw;
                else 
                { 
                    cmpMessage += ex.Message;
                }
            }
            finally
            {
                process.Close();
                CompileMessage = cmpMessage.TrimEnd('\n').TrimEnd('\r').Replace("\r\n", "\n").Split('\n').ToList();
            }
            return res;
        }

        public bool CreateExe()
        {
            Encoding sjisEnc = Encoding.GetEncoding("Shift_JIS");
            Hsc3_make(0, sjisEnc.GetBytes(Path.Combine(SystemDirectoryPath, "hsprt")), 0, 0);
            byte[] errbuf = new byte[32000];
            bool res = Hsc_getmes(errbuf, 0, 0, 0);   // 結果を取得
            CompileMessage = sjisEnc.GetString(errbuf).Replace("\0", "").TrimEnd('\n').TrimEnd('\r').Replace("\r\n", "\n").Split('\n').ToList();
            return res;
        }

        public static string GetRuntime(string axName)
        {
            var runtimeName = new byte[Util.MAX_PATH];
            Hsc3_getruntime(runtimeName, Encoding.GetEncoding("Shift_JIS").GetBytes(axName), 0, 0);
            return Encoding.GetEncoding("Shift_JIS").GetString(runtimeName).Replace("\0", "");
        }
#endif
    }
}
